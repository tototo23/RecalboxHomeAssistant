# /config/packages/recalbox.yaml
# Par Aurélien Tomassini

# Pour avoir recalbox sous forme d'une entité avec un status ON/OFF
mqtt:
  binary_sensor:
    - name: "Recalbox RPI3"
      unique_id: recalbox_console_rpi3
      state_topic: "recalbox/notifications/status"
      payload_on: "ON"
      payload_off: "OFF"
      device_class: power
      # On passe en "indisponible" après 2h sans nouvelles
      expire_after: 7200
      # On récupère en JSON des attributs pour récupérer
      # le nom du jeu, la console, l'URL de l'image, etc.
      json_attributes_topic: "recalbox/notifications/game"
      # On définit l'appareil ici
      device: &recalbox_device
        identifiers: "recalbox_rpi3_system"
        name: "Recalbox"
        model: "Raspberry Pi 3"
        manufacturer: "Recalbox"
        sw_version: "Latest" # Optionnel : version du système
        configuration_url: "http://recalbox.local" # Lien direct vers l'interface web
        
  # On crée des boutons pour éteindre/redémarrer la recalbox.
  button:
  - name: "Eteindre Recalbox"
    unique_id: eteindre_recalbox_btn
    icon: mdi:power-off
    device: *recalbox_device
    command_topic: "recalbox/commands/shutdown"
  - name: "Reboot Recalbox"
    unique_id: reboot_recalbox_btn
    icon: mdi:restart
    device: *recalbox_device
    command_topic: "recalbox/commands/reboot"

    
automation:
# Pour forcer le passage à OFF, on crée une petite automatisation interne
  - alias: "Recalbox Feedback Extinction"
    trigger:
      # On détecte quand l'ordre d'extinction est envoyé par le bouton
      - platform: mqtt
        topic: "recalbox/commands/shutdown"
    action:
      # On force immédiatement le statut à OFF dans MQTT
      - service: mqtt.publish
        data:
          topic: "recalbox/notifications/status"
          payload: "OFF"
          retain: true
          
# Pour convertir les actions MQTT en appel REST
  - alias: Lien Boutons MQTT vers REST
    description: Nécessaire pour faire fonctionner les boutons de reboot/shutdown de recalbox
    actions:
      - action: rest_command.{{ trigger.topic.split('/')[-1] }}_recalbox
    triggers:
      - topic: recalbox/commands/shutdown
        trigger: mqtt
      - topic: recalbox/commands/reboot
        trigger: mqtt


# Eteindre la recalbox : recalbox.local == 192.168.1.147
rest_command:
  shutdown_recalbox:
    url: "http://recalbox.local/api/system/shutdown"
    method: POST
  reboot_recalbox:
    url: "http://recalbox.local/api/system/reboot"
    method: POST
    
  # Récupère les roms d'une console précise
  recalbox_get_roms:
    url: "http://recalbox.local:81/api/systems/{{ console }}/roms"
    method: GET
  
  recalbox_launch_game:
    url: "http://recalbox.local:81/api/systems/{{ console }}/launcher"
    method: POST
    payload: "{{ path }}"
    content_type: "text/plain"


# ----- Assistant


# Pour les commandes intelligentes ON OFF : voix/texte
template:
- switch:
  - unique_id: switch_recalbox_assist
    turn_on:
    - action: notify.persistent_notification
      data:
        message: L'allumage de Recalbox n'est pas réalisable à distance. Alimentez votre Recalbox, ou appuyez sur son interrupteur.
    turn_off:
    - action: button.press
      target:
        entity_id: button.recalbox_eteindre_recalbox
      data: {}
    #default_entity_id: switch.recalbox_global
    name: Recalbox
    state: "{{ is_state('binary_sensor.recalbox_rpi3', 'on') }}"


# Pour les infos sur le jeu en cours
intent_script:
  RecalboxGameStatus:
    speech:
      text: >
        {% set game = state_attr('binary_sensor.recalbox_rpi3', 'game') %}
        {% set system = state_attr('binary_sensor.recalbox_rpi3', 'console') %}
        {% if is_state('binary_sensor.recalbox_rpi3', 'on') and game %}
          Tu joues à {{ game }} sur {{ system }}.
        {% elif is_state('binary_sensor.recalbox_rpi3', 'on') %}
          La Recalbox est allumée, mais aucun jeu n'est lancé.
        {% else %}
          La Recalbox est actuellement éteinte.
        {% endif %}


  # Pour lancer un jeu par la voix
  RecalboxLaunchGame:
    action:
      - action: script.recalbox_search_and_launch
        data:
          game_name: "{{ game }}"
          console_id: "{{ console }}"
        response_variable: script_output
      - stop: "Return value to intent script"
        response_variable: script_output
    speech:
      text: >
        {% set resp = action_response %}
        {% if resp is not none %}
            {{ resp.result }}
        {% elif not is_state('binary_sensor.recalbox_rpi3', 'on') %}
          La recalbox ne semble pas allumée, ou pas accessible.
        {% else %}
          Une erreur imprévue est survenue pendant l'exécution du script.
          Aucun status n'a été reçu du script de recherche. ({{ resp }})
        {% endif %}

script:
  recalbox_search_and_launch:
    mode: restart
    sequence:
    
      - variables:
          final_msg: "Erreur inconnue"
          final_success: "false"
    
      - if:
          - condition: not
            conditions:
              - condition: state
                entity_id: binary_sensor.recalbox_rpi3
                state: "on"
        then:
          - variables:
              reponse_finale: 
                success: false
                result: La Recalbox semble ne pas être allumée, ou non détectée. Assurez-vous de la voir connectée à Home Assistant pour la contrôler.
          - stop: "Recalbox is OFF"
            response_variable: reponse_finale
          
      # lister toutes les roms de la console
      - action: rest_command.recalbox_get_roms
        data:
          console: "{{ console_id }}"
        response_variable: rom_list
        continue_on_error: true # Permet de ne pas stopper le script si l'API échoue

      - if:
          - condition: template
            value_template: "{{ rom_list is not defined or rom_list['status'] != 200 }}"
        then:
          - variables:
              reponse_finale: 
                success: false
                result: "Impossible de récupérer la liste des jeux de {{ console_id }} actuellement (réponse de l'API : code HTTP {{ rom_list['status'] }})."
          - stop: "Cannot get Roms list"
            response_variable: reponse_finale
        
      - variables:
          search_pattern: "{{ game_name | replace(' ', ' .*') }}"
          # rom_list contient un tableau "roms"
          # dans lequel on va chercher si une rom a dans son "name" le nom du jeu à lancer.
          # si on le trouve, on récupère l'objet target_game qui contient le chemin vers la rom "target_game.path"
          target_game: >
            {% if rom_list.content is defined and rom_list.content.roms is defined %}
              {{ rom_list.content.roms | selectattr('name', 'search', search_pattern, ignorecase=True) | first | default(none) }}
            {% else %}
              none
            {% endif %}

      - if:
          - condition: template
            value_template: "{{ target_game is not none }}"
        then:
          - action: rest_command.recalbox_launch_game
            data:
              console: "{{ console_id }}"
              path: "{{ target_game.path }}"
            continue_on_error: true # Permet de ne pas stopper le script si l'API échoue
            response_variable: launch_result
          - variables:
              final_success: "{{ launch_result is defined and launch_result['status'] == 200 }}"
              final_msg: > 
                {% if final_success == 'True' %}
                  Le jeu {{ target_game.name }} a été trouvé et lancé sur {{ console_id }}.
                {% else %}
                  Le jeu {{ target_game.name }} a bien été trouvé sur {{ console_id }}, mais n'a malheureusement pas pu être lancé sur la Recalbox par son API.
                {% endif %}
        else:
          - variables:
              final_success: "false"
              final_msg: Le jeu {{ game_name }} n'a pas été trouvé sur {{ console_id }}
                
                
      - variables:
          reponse_finale: 
            success: "{{ final_success }}"
            result: "{{ final_msg }}"
      - stop: "Fin du script de recherche"
        response_variable: reponse_finale
        